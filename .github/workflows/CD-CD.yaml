name: Deploy HashiCorp Vault to Minikube (CI/CD Pipeline)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Manual trigger option

env:
  JFROG_REGISTRY: "triald4lybb.jfrog.io"
  JFROG_REPO: "vault-repo"
  IMAGE_NAME: "vault-server"
  BASE_VERSION: "1.0"
  IMAGE_TAG: "${{ github.run_number }}-${{ github.sha }}-$(date +'%Y%m%d')"
  K8S_NAMESPACE: "vault-deployment"
  K8S_DEPLOYMENT_NAME: "vault"
  HELM_TIMEOUT: "600s"

jobs:
  validate:
    runs-on: self-hosted
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Validate Environment Variables
        run: |
          required_vars=("JFROG_REGISTRY" "JFROG_REPO" "IMAGE_NAME" "K8S_NAMESPACE")
          for var in "${required_vars[@]}"; do
            if [ -z "${!var}" ]; then
              echo "Error: Required variable $var is not set"
              exit 1
            fi
          done

      - name: Validate Kubernetes Configuration
        run: |
          kubectl apply --dry-run=client -f kubernetes/ -n ${{ env.K8S_NAMESPACE }}

      - name: Lint Helm Chart
        run: |
          helm lint ./helm
          helm template vault ./helm --debug

  build:
    needs: validate
    runs-on: self-hosted
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Log in to JFrog Artifactory
        uses: docker/login-action@v2
        with:
          registry: ${{ env.JFROG_REGISTRY }}
          username: ${{ secrets.JFROG_USERNAME }}
          password: ${{ secrets.JFROG_PASSWORD }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          ignore-unfixed: true
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/Dockerfile
          push: true
          tags: ${{ env.JFROG_REGISTRY }}/${{ env.JFROG_REPO }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  deploy:
    needs: build
    runs-on: self-hosted
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Create Namespace
        run: |
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Update Helm Chart Version
        run: |
          yq eval ".version = \"1.0.${{ github.run_number }}\"" -i ./helm/Chart.yaml

      - name: Create Backup
        run: |
          kubectl get configmap -n ${{ env.K8S_NAMESPACE }} vault-config -o yaml > backup-config.yaml || true
          kubectl get secret -n ${{ env.K8S_NAMESPACE }} vault-ssl-cert -o yaml > backup-secrets.yaml || true

      - name: Deploy with Helm
        run: |
          helm upgrade --install vault ./helm \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --set image.repository=${{ env.JFROG_REGISTRY }}/${{ env.JFROG_REPO }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ env.IMAGE_TAG }} \
            --set imagePullSecrets[0].name=jfrog-registry-secret \
            --set server.ha.enabled=true \
            --create-namespace \
            --wait \
            --timeout ${{ env.HELM_TIMEOUT }}

      - name: Verify Deployment
        run: |
          kubectl wait --for=condition=ready pod -l app=vault --timeout=300s -n ${{ env.K8S_NAMESPACE }}
          kubectl get all -n ${{ env.K8S_NAMESPACE }}
          helm test vault -n ${{ env.K8S_NAMESPACE }} --logs

      - name: Verify Vault Health
        run: |
          kubectl port-forward svc/vault -n ${{ env.K8S_NAMESPACE }} 8200:8200 &
          sleep 10
          curl -k https://localhost:8200/v1/sys/health || echo "Vault is not reachable!"
          pkill -f "port-forward"

  cleanup:
    needs: deploy
    if: always()
    runs-on: self-hosted
    steps:
      - name: Cleanup Old Resources
        run: |
          # Clean old images from local Docker
          docker system prune -af --filter "until=24h"
          
          # Clean old Helm releases
          helm list -n ${{ env.K8S_NAMESPACE }} -o json | \
          jq -r '.[] | select(.name=="vault") | .revision' | \
          sort -n | head -n -5 | \
          xargs -I {} helm delete vault --revision {} -n ${{ env.K8S_NAMESPACE }} || true

      - name: Delete Older Docker Images from JFrog
        run: |
          curl -u "${{ secrets.JFROG_USERNAME }}:${{ secrets.JFROG_PASSWORD }}" \
            -X DELETE "https://${{ env.JFROG_REGISTRY }}/artifactory/api/docker/${{ env.JFROG_REPO }}/v2/${{ env.IMAGE_NAME }}/tags?olderThan=3d"

  notify:
    needs: [deploy, cleanup]
    if: always()
    runs-on: self-hosted
    steps:
      - name: Notify Slack on Success
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_MESSAGE: 'Vault deployment successful! :rocket:'
          SLACK_COLOR: 'good'

      - name: Notify Slack on Failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_MESSAGE: 'Vault deployment failed! :x:'
          SLACK_COLOR: 'danger'